class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # make a frequency map
        hashmap = {}
        for n in nums:
            if n not in hashmap:
                hashmap[n] = 0
            hashmap[n] += 1
        
        bucket = []
        for num, count in hashmap.items():
            bucket[count] = num
        
        # when choosing the top k elements, use bucket sort to keep the time complexity O(n)
        ans = []
        for i in range(len(bucket), 1):
            print(i)

    # time complexity: O(n) since this solution uses O(n) sorting algorithm(bucket sort)
    # space complexity: O(n) because of the frequency map that has the same length as nums

    # when asked to find the kth smallest or largest elements, the first method that comes to mind is to use a min/max heap or sorting